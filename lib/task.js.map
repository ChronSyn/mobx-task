{"version":3,"sources":["../src/task.js"],"names":["require","observable","computed","action","proxyGetters","promiseTry","createTask","fn","opts","swallow","state","task","setState","error","undefined","result","Promise","resolve","apply","then","catch","err","stateGetter","taskState","taskStateSchema","ref","pending","resolved","rejected","taskStateSchemaKeys","Object","keys","setupTask","setup","func","assign","bind","args","bound","Function","prototype","wrap","wrapper","wrapped","arguments","match","obj","taskCreatorFactory","arg1","arg2","arg3","makeDecorator","inner","decorator","target","name","descriptor","value","writable","get","t","getter"],"mappings":"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","file":"task.js","sourcesContent":["const { observable, computed, action } = require('mobx')\nconst { proxyGetters, promiseTry } = require('./utils')\n\n/**\n * Wraps the given function in a task function.\n *\n * @param  {Function} fn\n * @return {Task}\n */\nfunction createTask (fn, opts) {\n  opts = {\n    swallow: false,\n    state: 'pending',\n    ...opts\n  }\n\n  /**\n   * The actual task function.\n   */\n  function task () {\n    return promiseTry(() => {\n      task.setState({ state: 'pending', error: undefined, result: undefined })\n      return Promise.resolve(fn.apply(this, arguments)).then((result) => {\n        task.setState({ state: 'resolved', error: undefined, result })\n        return result\n      }).catch(err => {\n        task.setState({ state: 'rejected', error: err, result: undefined })\n        if (!opts.swallow) {\n          throw err\n        }\n      })\n    })\n  }\n\n  const stateGetter = (state) => computed(() => taskState.state === state)\n  const taskStateSchema = {\n    state: opts.state,\n    error: observable.ref(opts.error),\n    result: opts.result,\n    pending: stateGetter('pending'),\n    resolved: stateGetter('resolved'),\n    rejected: stateGetter('rejected')\n  }\n\n  const taskStateSchemaKeys = Object.keys(taskStateSchema)\n  const taskState = observable(taskStateSchema)\n\n  setupTask(task, taskState, taskStateSchemaKeys)\n  return task\n}\n\n/**\n * Assigns the task methods and state to the given function.\n */\nfunction setupTask (fn, taskState, taskStateSchemaKeys) {\n  const setup = (func) => setupTask(func, taskState, taskStateSchemaKeys)\n  proxyGetters(fn, taskState, taskStateSchemaKeys)\n  Object.assign(fn, {\n    /**\n     * Patch `bind` so we always return\n     * the task function (with the additional properties)\n     */\n    bind: (...args) => {\n      const bound = Function.prototype.bind.apply(fn, args)\n      return setup(bound)\n    },\n    /**\n     * Wraps the task and returns the new function with the task stuff attached.\n     *\n     * @param {Function} wrapper\n     * Invoked with the inner function as the only parameter.\n     *\n     * @return {Task}\n     * Wrapped function as a task.\n     */\n    wrap: (wrapper) => {\n      return setup(wrapper(function wrapped () {\n        return fn.apply(this, arguments)\n      }))\n    },\n    /**\n     * Assigns the given properties to the task.\n     * E.g. task.setState({ state: 'resolved', result: 1337 })\n     */\n    setState: action((opts) => {\n      Object.assign(taskState, opts)\n      return fn\n    }),\n    /**\n     * Given an object, returns the value for the key which equals the\n     * current state, or undefined if not specified.\n     */\n    match: (obj) => {\n      const state = taskState.state\n      const match = obj[state]\n\n      if (!match) {\n        return undefined\n      }\n\n      if (state === 'resolved') {\n        return match(taskState.result)\n      }\n\n      if (state === 'rejected') {\n        return match(taskState.error)\n      }\n\n      return match()\n    }\n  })\n  return fn\n}\n\n/**\n * Returns a function, which returns either a decorator, a task, or a decorator factory.\n */\nfunction taskCreatorFactory (opts) {\n  /**\n   * Decorator to make async functions \"so fucking graceful\", by maintaining observables for errors\n   * and running state.\n   */\n  return function task (arg1, arg2, arg3) {\n    if (typeof arg1 === 'function') {\n      // regular invocation\n      return createTask(arg1, { ...opts, ...arg2 })\n    }\n\n    const makeDecorator = (inner) => {\n      return function decorator (target, name, descriptor) {\n        if (descriptor.value) {\n          const fn = descriptor.value\n          delete descriptor.writable\n          delete descriptor.value\n          descriptor.value = createTask(fn, { ...opts, ...inner })\n        } else {\n          const get = descriptor.get\n          let t\n          descriptor.get = function getter () {\n            /* istanbul ignore next */\n            if (t) {\n              return t\n            }\n\n            const fn = get.apply(this, arguments)\n            t = createTask(fn, { ...opts, ...inner })\n            return t\n          }\n        }\n      }\n    }\n\n    // decorator invocation\n    if (typeof arg2 === 'string') {\n      // parameterless - @task method()\n      return makeDecorator()(arg1, arg2, arg3)\n    }\n\n    // parameters - @task({ state: 'resolved' }) method()\n    return makeDecorator({ ...opts, ...arg1 })\n  }\n}\n\nexport const task = taskCreatorFactory()\ntask.resolved = taskCreatorFactory({ state: 'resolved' })\ntask.rejected = taskCreatorFactory({ state: 'rejected' })\n"]}